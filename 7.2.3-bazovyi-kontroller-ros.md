# 7.2.3 Базовый контроллер ROS

На следующем уровне абстракции желаемая скорость робота указывается в реальных единицах измерения, таких как метры и радианы в секунду. Также распространено использовать некоторую форму контроля PID. PID расшифровывается как «Пропорционально-интегральная производная» и носит так называемое название, поскольку алгоритм управления корректирует скорости вращения колес, основываясь не только на разнице \(пропорциональной\) погрешности между фактической и требуемой скоростью, но также на производной и интегральной по времени. Вы можете узнать больше о PID-контроле в [Википедии](http://en.wikipedia.org/wiki/PID_controller). Для наших целей нам просто нужно знать, что контроллер сделает все возможное, чтобы переместить робота так, как мы просили. 

Драйвер и PID-контроллер обычно объединяются в одном узле ROS, называемом базовым контроллером. Базовый контроллер всегда должен работать на компьютере, подключенном непосредственно к контроллеру двигателя, и обычно является одним из первых узлов, запускаемых при запуске робота. В Gazebo также можно смоделировать ряд базовых контроллеров, включая [TurtleBot](http://wiki.ros.org/turtlebot_simulator), [PR2](http://wiki.ros.org/pr2_simulator/Tutorials) и [Erratic](http://wiki.ros.org/erratic_robot).

Узел базового контроллера обычно публикует данные одометрии в теме / odom и прослушивает команды движения в теме / cmd\_vel. В то же время узел контроллера обычно \(но не всегда\) публикует преобразование из кадра / odom в базовый кадр - либо / base\_linkor / base\_footprint. В основном «не всегда», потому что некоторые роботы, такие как TurtleBot, используют пакет [robot\_pose\_ekf](http://ros.org/wiki/robot_pose_ekf), чтобы объединить одометрию колеса и данные гироскопа, чтобы получить более точную оценку положения и ориентации робота. В этом случае это узел robot\_pose\_ekf, который публикует преобразование из / odomto / base\_footprint. \(Therobot\_pose\_ekfpackageimplementsan Расширенный фильтр Калмана, о котором вы можете прочитать на вики-странице, на которую ссылается выше.\) 

Как только у нас есть базовый контроллер для нашего робота, ROS предоставляет инструменты, необходимые для выдачи команд движения либо из командной строки, либо с помощью других узлов ROS для публикации этих команд на основе плана более высокого уровня. На этом уровне не имеет значения, какое оборудование мы используем для нашего базового контроллера: наше программирование может фокусироваться исключительно на желаемых линейных и угловых скоростях в реальных единицах измерения, и любой код, который мы пишем, должен работать на любом базовом контроллере с интерфейсом ROS 

