# 7.7 "Мы уже приехали?" Подойдя на расстояние с одометра

Когда мы просим нашего робота двигаться или вращаться с определенной скоростью, как мы узнаем, что он действительно выполняет то, что мы просили? Например, если мы опубликуем сообщение Twist для перемещения робота вперед со скоростью 0,2 м / с, как мы узнаем, что робот на самом деле не движется со скоростью 0,18 м / с? На самом деле, как мы узнаем, что оба колеса движутся с одинаковой скоростью?

Как мы объясняли ранее в этой главе, базовый узел контроллера робота использует одометрию и ПИД-управление, чтобы превратить запросы движения в реальные скорости. Точность и надежность этого процесса зависит от внутренних датчиков робота, точности процедуры калибровки и условий окружающей среды. \(Например, некоторые поверхности могут позволить колесам слегка скользить, что может испортить отображение между счетчиками энкодера и пройденным расстоянием.\)

Внутренняя одометрия робота может быть дополнена внешними измерениями положения и / или ориентации робота. Например, можно использовать настенные визуальные маркеры, такие как проверочные символы, вместе с пакетами ROS [ar\_pose](http://wiki.ros.org/ar_pose), [ar\_kinect](http://wiki.ros.org/ar_kinect) или [ar\_track\_alvar](http://wiki.ros.org/ar_track_alvar), чтобы обеспечить довольно точную локализацию робота в комнате. Аналогичный метод использует сопоставление визуальных функций без необходимости использования искусственных маркеров \([ccny\_rgbd\_tools](http://wiki.ros.org/ccny_rgbd_tools), [rgbdslam](http://wiki.ros.org/rgbdslam), [RTABMap](http://introlab.github.io/rtabmap/)\), а еще один пакет \([laser\_scan\_matcher](http://wiki.ros.org/laser_scan_matcher)\) использует сопоставление лазерного сканирования. Наружные роботы часто используют [GPS](http://wiki.ros.org/robot_pose_ekf/Tutorials/AddingGpsSensor) для оценки положения в дополнение к другим формам одометрии.

Для целей этой книги мы будем использовать термин «одометрия» для обозначения данных о внутреннем положении. Однако, независимо от того, как измеряется одометрия, ROS предоставляет тип сообщения для хранения информации; а именно [nav\_msgs / Одометрия](http://www.ros.org/doc/api/nav_msgs/html/msg/Odometry.html). Сокращенное определение типа сообщения Одометрия показано ниже:

> ```text
> Header header
> string child_frame_id
> geometry_msgs/PoseWithCovariance pose
> geometry_msgs/TwistWithCovariance twist
> ```

Здесь мы видим, что сообщение Odometry состоит из заголовка, строки, идентифицирующей child\_frame\_id, и двух вложенных сообщений, одно для PoseWithCovariance и одно для TwistWithCovariance.

Чтобы увидеть расширенную версию определения, выполните команду:

```text
$ rosmsg show nav_msgs/Odometry
```

который должен дать следующий результат:

> ```
> Header header
>   uint32 seq
>   time stamp
>   string frame_id
> string child_frame_id
> geometry_msgs/PoseWithCovariance pose
>   geometry_msgs/Pose pose
>     geometry_msgs/Point position
>       float64 x
>       float64 y
>       float64 z
>     geometry_msgs/Quaternion orientation
>       float64 x
>       float64 y
>       float64 z
>       float64 w
>   float64[36] covariance
> geometry_msgs/TwistWithCovariance twist
>   geometry_msgs/Twist twist
>     geometry_msgs/Vector3 linear
>       float64 x
>       float64 y
>       float64 z
>     geometry_msgs/Vector3 angular
>       float64 x
>       float64 y
>       float64 z
>   float64[36] covariance
> ```

Под-сообщение PoseWithCovariance записывает положение и ориентацию робота, в то время как компонент TwistWithCovariance дает нам линейную и угловую скорости, которые мы уже видели. И предложение, и его применение могут быть дополнены ковариационной матрицей, которая измеряет неопределенность в различных измерениях.

Заголовок и child\_frame\_id определяют системы отсчета, которые мы используем для измерения расстояний и углов. Он также предоставляет временную метку для каждого сообщения, поэтому мы знаем не только, где мы находимся, но и когда. По соглашению, измерения одометрии в ROS используют / odom в качестве идентификатора родительского кадра и / base\_link \(или / base\_footprint\) в качестве идентификатора дочернего кадра. В то время как фрейм / base\_link соответствует реальной физической части робота, фрейм / odom определяется сдвигами и поворотами, инкапсулированными в данные одометрии. Эти преобразования перемещают робота относительно фрейма / odom. Если мы отобразим модель робота в RViz и установим фиксированную рамку в / odom, позиция робота будет отражать то, где робот «думает», относительно ее начальной позиции.

